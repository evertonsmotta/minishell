https://rodsmade.notion.site/Acelera-Minishell-f6c3f8463e3e4580b4e61f4886036faf
https://github.com/madebypixel02/minishell

Nome do programa: minishell
Entregar arquivos: Makefile, *.h, *.c
Makefile: name, all, clean, fclena, re
Libft autorizado: Sim

Seu shell deve:

- Exibir um prompt enquanto espera por um novo comando.

- Trabalhar com historico (history).

- Pesquise e inicie o executável correto (com base no PATH variável ou usando um
relativo ou um caminho absoluto).

- Evite usar mais deuma variável global para indicar um signal recebido. Considere as
implicações: esta abordagem garante que seu manipulador de sinal não acessará seu
principais estruturas de dados.
	
	Cuidado. Esta variável global não pode fornecer nenhuma outra informação
	ou acesso a dados além do número de um sinal recebido. Portanto é proibido
	usar estruturas do tipo "norm" no global.


- Não interpretar aspas não fechadas ou caracteres especiais que não sejam exigidos pelo
assunto, como \ (barra invertida) ou ; (ponto e vírgula).

- Handle ' (aspas simples) que deve impedir que o shell interprete os
metacaracteres na sequência citada.

- Handle "(aspas duplas) que deve evitar que o shell interprete os
metacaracteres na sequência citada, exceto $ (dollar sign).

- Implemento redirecionamentos:
	◦ < deve redirecionar a entrada.
	◦ > deve redirecionar a saída.
	◦ << deve receber um delimitador e, em seguida, leia a entrada até que uma linha contendo o
	delimitador seja vista. No entanto, não é necessário atualizar o histórico!
	◦ >> deve redirecionar a saída no modo de acréscimo.

- Implemento pipes(|). A saída de cada comando no pipeline é conectada
à entrada do próximo comando por meio de um pipe.

- Lidar variáveis ambientais($ seguido por uma sequência de caracteres) que devem se
expandir para seus valores.

- Lidar com $? que deve se expandir para o status de saída do pipeline em primeiro plano executado
mais recentemente.

- Lidar Ctrl-C, Ctrl-D e ctrl-\ que deveria se comportar como no bash.

- No modo interativo:
	- Ctrl-C exibe um novo prompt em uma nova linha.
	- Ctrl-D sai do shell.
	- ctrl-\ faz nada.

- Seu shell deve implementar o seguinte embutidos(builtins):
	- echo com opção -n
	- cd com apenas um caminho relativo ou absoluto(PATH)
	- pwd sem opções
	- export sem opções
	- unset sem opções
	- env sem opções ou argumentos
	- exit sem opções

A funcao readline() pode causar vazamentos de memória. Você não precisa consertá-los. Mas isso
não significa que seu próprio código, sim, o código que você escreveu pode ter vazamentos de
memória.



External functs.:
readline
rl_clear_history
rl_on_new_line
rl_replace_line
rl_redisplay
add_history
printf
malloc
free
write
access
open
read
close
fork
wait
waitpid
wait3
wait4
signal
sigaction
sigemptyset
sigaddset
kill
exit
getcwd
chdir
stat
lstat
fstat
unlink
execve
dup
dup2
pipe
opendir
readdir
closedir
strerror
perror
isatty
ttyname
ttyslot
ioctl
getenv
tcsetattr
tcgetattr
tgetent
tgetflag
tgetnum
tgetstr
tgoto
tputs
